// DON'T EDIT *** generated by ormgen *** DON'T EDIT //
package store





import (
	"database/sql" 
	"github.com/lib/pq" 
	"github.com/gofrs/uuid"
	"strings"
	"time"
	"fmt"
	"log"
)

func checkSqlUUIDValue(v interface{}) uuid.UUID {
	val := v.(*uuid.NullUUID)
	if !val.Valid{
		return uuid.UUID{}	
	}
	return val.UUID
} 

func checkSqlInt64Value(v interface{}) int64 {
	val := v.(*sql.NullInt64)
	if !val.Valid {
		return 0
	}
	return val.Int64
}

func checkSqlStringValue(v interface{}) string {
	val := v.(*sql.NullString)
	if !val.Valid {
		return ""
	}
	return val.String
}

func checkSqlBoolValue(v interface{}) bool {
	val := v.(*sql.NullBool)
	if !val.Valid {
		return false
	}
	return val.Bool
}

func checkSqlTimeValue(v interface{}) time.Time {
	val := v.(*pq.NullTime)
	if !val.Valid {
		return time.Time{}
	}
	return val.Time
}

func hasWhere(query string) bool {
	if strings.Contains(query, "WHERE") {
		return true
	}
	return false
}

func addPlaceholders(query string, params []interface{}) string {
	swapin := make([]interface{}, len(params))
	for k, _ := range params {
		swapin[k] = k+1
	}
	return fmt.Sprintf(query, swapin...)
}

type Query interface {
	GetQuery() string
	GetParams() []interface{}
	GetDepth() int
}





type proxyUserType struct {
	*UserType
}

func newProxyUserType () *proxyUserType {
	return &proxyUserType{ UserType:new(UserType)}
}

type UserTypeQuery struct {
	depth int
	query string
	params []interface{}
}

func(q *UserTypeQuery) GetQuery() string {
	return addPlaceholders(strings.Replace(q.query, "$p", "$%d", -1), q.params)
}

func(q *UserTypeQuery) GetParams() []interface{} {
	return q.params
}

func(q *UserTypeQuery) GetDepth() int {
	return q.depth
}

func(q *UserTypeQuery) Transform(t func(string)string) *UserTypeQuery {
	q.query = t(q.query)
	return q
}

func NewUserTypeQuery(lvl int) *UserTypeQuery {
	return &UserTypeQuery{
			query:fmt.Sprintf("%s %s", UserTypeSelect(lvl), UserTypeFrom(lvl)), 
			params:make([]interface{}, 0),
			depth: lvl,
		}
}

func DeleteUserTypeQuery(lvl int) *UserTypeQuery {
	return &UserTypeQuery{
		query:fmt.Sprintf("DELETE %s", UserTypeFrom(lvl)),
		params:make([]interface{}, 0),
		depth: lvl,
		}
}

func (q *UserTypeQuery) AddParams(value []interface{}) *UserTypeQuery {
	q.params = append(q.params, value...)
	return q
}

//TODO add where in
func (q *UserTypeQuery) Where(prop, operator string, value interface{}) *UserTypeQuery {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s WHERE %s %s $p", q.query, UserTypePropToSql[prop], operator)
	return q
}

func (q *UserTypeQuery) And(prop, operator string, value interface{}) *UserTypeQuery {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using AND without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s AND %s %s $p", q.query, UserTypePropToSql[prop], operator)
	return q
}

func (q *UserTypeQuery) Or(prop string, operator string, value interface{}) *UserTypeQuery {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using OR without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s OR %s %s $p", q.query, UserTypePropToSql[prop], operator)
	return q
}

//TODO allow multiple columns to sort on
func (q *UserTypeQuery) OrderBy(prop, dir string) *UserTypeQuery {
	q.query = fmt.Sprintf("%s ORDER BY %s %s", q.query, UserTypePropToSql[prop], dir)
	return q
}

func (q *UserTypeQuery) Limit(count int) *UserTypeQuery {
	q.params = append(q.params, count)
	q.query = fmt.Sprintf("%s LIMIT $p", q.query)
	return q
}

func (q *UserTypeQuery) KeyUp(prop string, start, limit int) *UserTypeQuery {
	q.params = append([]interface{}{limit}, q.params...)
	q.query = strings.Replace(q.query, "FROM registration_user_type", "FROM (SELECT * FROM registration_user_type LIMIT $p) AS", 1)
	if start > 0 {
		q.params = append(q.params, start)
		if w := hasWhere(q.query); w {
			q = q.Where(prop, ">", start)
		} else {
			q = q.And(prop, ">", start)
		}
	}
	q = q.OrderBy(prop, "ASC")
	return q
}

func (q *UserTypeQuery) KeyDown(prop string, start, limit int) *UserTypeQuery {
	q.params = append([]interface{}{limit}, q.params...)
	q.params = append([]interface{}{start}, q.params...)
	sqlProp := UserTypePropToSql[prop]
	props := strings.Split(sqlProp, ".")
	p := props[len(props)-1]
	q.query = strings.Replace(q.query, "FROM registration_user_type", "FROM (SELECT * FROM registration_user_type limited WHERE limited.%[1]s < $p ORDER BY limited.%[1]s DESC LIMIT $p) AS", 1)
	q.query = fmt.Sprintf(q.query, p)
	q.query = fmt.Sprintf(`SELECT t.* FROM ( %s ) AS t ORDER BY t.%s ASC`, 
			q.query, p)
	return q	
}

func (q *UserTypeQuery) Execute(ctx SQLContext) ([]*UserType, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return QueryUserTypes(q.query, q.params, q.depth, ctx)
}

func (q *UserTypeQuery) Single(ctx SQLContext) (*UserType, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return QueryUserType(q.query, q.params, q.depth, ctx)
}

func FindUserTypeByID(id int64, lvl int, ctx SQLContext) (*UserType, error) {
        return NewUserTypeQuery(lvl).Where("ID", "=", id).Single(ctx)
}


func DeleteUserType(entity *UserType, ctx SQLContext) (err error) {
	if entity.ID == 0 {
		return fmt.Errorf("Cannot delete without entity identifier %s on %s", "Delete", "UserType")
	}
	_, err = ctx.Exec("DELETE FROM registration_user_type WHERE ut_id = $1", entity.ID)
	return
}

func InsertUserType(ctx SQLContext, entity ...*UserType) ([]interface{} , error) {
	return insertUserType(ctx, "", entity...)
}

func UpsertUserType(ctx SQLContext,  on string, entity ...*UserType) ([]interface{}, error) {
	return insertUserType(ctx, on, entity...)
}


func insertUserType(ctx SQLContext, on string, entities ...*UserType) ([]interface{}, error) {  
	eCount := len(entities)
	returnIds := make([]interface{}, eCount)	
	if eCount == 0 {
		return returnIds, nil
	}
	vQuery := make([]string, eCount)
	values := make([]interface{}, 0)
	for i, entity := range entities {
	tv := make([]interface{}, 1)	
	tv[0] = entity.Name
	values = append(values, tv...)
	holders := make([]interface{}, 1)
	for f := 0;f < 1;f++{
		holders[f] = (f+1)+(i*1)
	}
	vQuery[i] = fmt.Sprintf(`($%d)`, holders...)
	} 
	query := `INSERT INTO registration_user_type`
	if len(values) == 0 {
		 query = fmt.Sprintf("%s DEFAULT VALUES", query)
	} else {
		query = fmt.Sprintf(`%s (name) VALUES %s`, query, strings.Join(vQuery, ", "))
	}
	if on != "" {
		query = fmt.Sprintf("%s ON CONFLICT %s", query, on)
	}
	query = fmt.Sprintf("%s RETURNING ut_id", query)
	if(eCount == 1){
		if err := ctx.QueryRow(query, values...).Scan(&returnIds[0]); err != nil {
			return returnIds, err
		}
		return returnIds, nil
		
	} else {
		rows, err := ctx.Query(query, values...)
		if err != nil {
			return returnIds, err
		}
		defer rows.Close()
		cnt := 0
		for rows.Next() {
			if err = rows.Scan(&returnIds[cnt]); err != nil {
				return returnIds, err
			}
			cnt++
		}
		if cErr := rows.Close(); cErr != nil {
			return returnIds, cErr
		}
		if err := rows.Err(); err != nil {
			return returnIds, err
		}
	}
	return returnIds, nil
	
}



func UserTypeFrom(lvl int) string { 
	return `FROM registration_user_type rgt`
}

func UserTypeSelect(lvl int) string { 
	return `SELECT rgt.ut_id, rgt.name`
}


func UpdateUserType(entity *UserType, ctx SQLContext) (err error) { 
	if entity.ID == 0 {
		return fmt.Errorf("Cannot update without entity identifier %s on %s", "Update", "UserType")
	}
	queryPrts := make([]string, 1)
	updateFields := make([]interface{}, 1+1)
	updateFields[0] = entity.Name
	queryPrts[0] = `name = $1`
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE ut_id = $2`
	queryStr := fmt.Sprintf("SET %s WHERE ut_id = $2", strings.Join(queryPrts, ", "))
	updateFields[1] = entity.ID
	_, err = ctx.Exec(`UPDATE registration_user_type ` + queryStr, updateFields...)
	return
}



func QueryUserType(query string, params []interface{}, lvl int, ctx SQLContext) (*UserType, error) {
	return LoadUserType(ctx.QueryRow(query, params...))
}

func QueryUserTypes(query string, params []interface{}, lvl int, ctx SQLContext) ([]*UserType, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*UserType{}, err
	}
	return LoadUserTypes(rows)
}

func LoadUserType(r *sql.Row) (*UserType, error) {
	var s UserType
	if err := r.Scan(
		&s.ID,
		&s.Name,
	); err != nil {
		return nil, err
	}
	return &s, nil
}

func LoadUserTypes(rs *sql.Rows) ([]*UserType, error) {
	defer rs.Close()
	structs := make([]*UserType, 0, 16)
	var err error
	for rs.Next() {
		var s UserType
		if err = rs.Scan(
			&s.ID,
			&s.Name,
		); err != nil {
			return nil, err
		}
		structs = append(structs, &s)
	}
	if cErr := rs.Close(); cErr != nil {
		return nil, cErr
	}
	if err = rs.Err(); err != nil {
		return nil, err
	}
	return structs, nil
}


type proxyUser struct {
	*User
	proxyUserType *proxyUserType
}

func newProxyUser () *proxyUser {
	return &proxyUser{ User:new(User)}
}

type UserQuery struct {
	depth int
	query string
	params []interface{}
}

func(q *UserQuery) GetQuery() string {
	return addPlaceholders(strings.Replace(q.query, "$p", "$%d", -1), q.params)
}

func(q *UserQuery) GetParams() []interface{} {
	return q.params
}

func(q *UserQuery) GetDepth() int {
	return q.depth
}

func(q *UserQuery) Transform(t func(string)string) *UserQuery {
	q.query = t(q.query)
	return q
}

func NewUserQuery(lvl int) *UserQuery {
	return &UserQuery{
			query:fmt.Sprintf("%s %s", UserSelect(lvl), UserFrom(lvl)), 
			params:make([]interface{}, 0),
			depth: lvl,
		}
}

func DeleteUserQuery(lvl int) *UserQuery {
	return &UserQuery{
		query:fmt.Sprintf("DELETE %s", UserFrom(lvl)),
		params:make([]interface{}, 0),
		depth: lvl,
		}
}

func (q *UserQuery) AddParams(value []interface{}) *UserQuery {
	q.params = append(q.params, value...)
	return q
}

//TODO add where in
func (q *UserQuery) Where(prop, operator string, value interface{}) *UserQuery {
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s WHERE %s %s $p", q.query, UserPropToSql[prop], operator)
	return q
}

func (q *UserQuery) And(prop, operator string, value interface{}) *UserQuery {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using AND without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s AND %s %s $p", q.query, UserPropToSql[prop], operator)
	return q
}

func (q *UserQuery) Or(prop string, operator string, value interface{}) *UserQuery {
	if w := hasWhere(q.query); !w {
		log.Fatalf("using OR without WHERE clause")
	}
	q.params = append(q.params, value)
	q.query = fmt.Sprintf("%s OR %s %s $p", q.query, UserPropToSql[prop], operator)
	return q
}

//TODO allow multiple columns to sort on
func (q *UserQuery) OrderBy(prop, dir string) *UserQuery {
	q.query = fmt.Sprintf("%s ORDER BY %s %s", q.query, UserPropToSql[prop], dir)
	return q
}

func (q *UserQuery) Limit(count int) *UserQuery {
	q.params = append(q.params, count)
	q.query = fmt.Sprintf("%s LIMIT $p", q.query)
	return q
}

func (q *UserQuery) KeyUp(prop string, start, limit int) *UserQuery {
	q.params = append([]interface{}{limit}, q.params...)
	q.query = strings.Replace(q.query, "FROM registration_user", "FROM (SELECT * FROM registration_user LIMIT $p) AS", 1)
	if start > 0 {
		q.params = append(q.params, start)
		if w := hasWhere(q.query); w {
			q = q.Where(prop, ">", start)
		} else {
			q = q.And(prop, ">", start)
		}
	}
	q = q.OrderBy(prop, "ASC")
	return q
}

func (q *UserQuery) KeyDown(prop string, start, limit int) *UserQuery {
	q.params = append([]interface{}{limit}, q.params...)
	q.params = append([]interface{}{start}, q.params...)
	sqlProp := UserPropToSql[prop]
	props := strings.Split(sqlProp, ".")
	p := props[len(props)-1]
	q.query = strings.Replace(q.query, "FROM registration_user", "FROM (SELECT * FROM registration_user limited WHERE limited.%[1]s < $p ORDER BY limited.%[1]s DESC LIMIT $p) AS", 1)
	q.query = fmt.Sprintf(q.query, p)
	q.query = fmt.Sprintf(`SELECT t.* FROM ( %s ) AS t ORDER BY t.%s ASC`, 
			q.query, p)
	return q	
}

func (q *UserQuery) Execute(ctx SQLContext) ([]*User, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return QueryUsers(q.query, q.params, q.depth, ctx)
}

func (q *UserQuery) Single(ctx SQLContext) (*User, error) {
	q.query = strings.Replace(q.query, "$p", "$%d", -1)
	q.query = addPlaceholders(q.query, q.params)
	return QueryUser(q.query, q.params, q.depth, ctx)
}

func FindUserByID(id int64, lvl int, ctx SQLContext) (*User, error) {
        return NewUserQuery(lvl).Where("ID", "=", id).Single(ctx)
}


func DeleteUser(entity *User, ctx SQLContext) (err error) {
	if entity.ID == 0 {
		return fmt.Errorf("Cannot delete without entity identifier %s on %s", "Delete", "User")
	}
	_, err = ctx.Exec("DELETE FROM registration_user WHERE u_id = $1", entity.ID)
	return
}

func InsertUser(ctx SQLContext, entity ...*User) ([]interface{} , error) {
	return insertUser(ctx, "", entity...)
}

func UpsertUser(ctx SQLContext,  on string, entity ...*User) ([]interface{}, error) {
	return insertUser(ctx, on, entity...)
}


func insertUser(ctx SQLContext, on string, entities ...*User) ([]interface{}, error) {  
	eCount := len(entities)
	returnIds := make([]interface{}, eCount)	
	if eCount == 0 {
		return returnIds, nil
	}
	vQuery := make([]string, eCount)
	values := make([]interface{}, 0)
	for i, entity := range entities {
	tv := make([]interface{}, 4)	
	tv[0] = entity.Updated
	tv[1] = entity.Name
	tv[2] = entity.FirstName
	if entity.UserType == nil {
		tv[3] = nil
	} else {
		tv[3] = entity.UserType.ID
	}
	values = append(values, tv...)
	holders := make([]interface{}, 4)
	for f := 0;f < 4;f++{
		holders[f] = (f+1)+(i*4)
	}
	vQuery[i] = fmt.Sprintf(`($%d, $%d, $%d, $%d)`, holders...)
	} 
	query := `INSERT INTO registration_user`
	if len(values) == 0 {
		 query = fmt.Sprintf("%s DEFAULT VALUES", query)
	} else {
		query = fmt.Sprintf(`%s (updated, name, firstname, registration_usertype_id) VALUES %s`, query, strings.Join(vQuery, ", "))
	}
	if on != "" {
		query = fmt.Sprintf("%s ON CONFLICT %s", query, on)
	}
	query = fmt.Sprintf("%s RETURNING u_id", query)
	if(eCount == 1){
		if err := ctx.QueryRow(query, values...).Scan(&returnIds[0]); err != nil {
			return returnIds, err
		}
		return returnIds, nil
		
	} else {
		rows, err := ctx.Query(query, values...)
		if err != nil {
			return returnIds, err
		}
		defer rows.Close()
		cnt := 0
		for rows.Next() {
			if err = rows.Scan(&returnIds[cnt]); err != nil {
				return returnIds, err
			}
			cnt++
		}
		if cErr := rows.Close(); cErr != nil {
			return returnIds, cErr
		}
		if err := rows.Err(); err != nil {
			return returnIds, err
		}
	}
	return returnIds, nil
	
}



type UserLoader func(*sql.Rows) ([]*User, error)

type SingleUserLoader func(*sql.Rows) (*User, error)

var UserLoaders map[int]UserLoader = map[int]UserLoader{ 
	0:LoadUsers_lvl0,
	1:LoadUsers_lvl1,
	2:LoadUsers_lvl2,
}

var SingleUserLoaders map[int]SingleUserLoader = map[int]SingleUserLoader{ 
	0:LoadUser_lvl0,
	1:LoadUser_lvl1,
	2:LoadUser_lvl2,
}

func QueryUsers(query string, params []interface{}, lvl int, ctx SQLContext) ([]*User, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return []*User{}, err
	}
	return UserLoaders[lvl](rows)
}

func QueryUser(query string, params []interface{}, lvl int, ctx SQLContext) (*User, error) {
	rows, err := ctx.Query(query, params...)
	if err != nil {
		return nil, err
	}
	return SingleUserLoaders[lvl](rows)
}

var UserSelects map[int]func()string = map[int]func()string{ 
	0:UserSelect_lvl0,
	1:UserSelect_lvl1,
	2:UserSelect_lvl2,
}

func UserSelect(lvl int) string {
	return UserSelects[lvl]()
}

var UserFroms map[int]func()string = map[int]func()string{ 
	0:UserFrom_lvl0,
	1:UserFrom_lvl1,
	2:UserFrom_lvl2,
}

func UserFrom(lvl int) string {
	return UserFroms[lvl]()
}


func UpdateUser(entity *User, ctx SQLContext) (err error) { 
	if entity.ID == 0 {
		return fmt.Errorf("Cannot update without entity identifier %s on %s", "Update", "User")
	}
	queryPrts := make([]string, 4)
	updateFields := make([]interface{}, 4+1)
	updateFields[0] = entity.Updated
	queryPrts[0] = `updated = $1`
	updateFields[1] = entity.Name
	queryPrts[1] = `name = $2`
	updateFields[2] = entity.FirstName
	queryPrts[2] = `firstname = $3`
	if entity.UserType == nil || entity.UserType.ID == 0 {
		updateFields[3] = nil
	} else {
		updateFields[3] = entity.UserType.ID
	}
	queryPrts[3] = `registration_usertype_id = $4`
	//queryStr := strings.Join(queryPrts, ", ") + ` WHERE u_id = $5`
	queryStr := fmt.Sprintf("SET %s WHERE u_id = $5", strings.Join(queryPrts, ", "))
	updateFields[4] = entity.ID
	query := `UPDATE registration_user ` + queryStr
	_, err = ctx.Exec(query, updateFields...)
	return
}

